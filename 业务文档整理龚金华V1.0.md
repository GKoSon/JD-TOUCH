2.1 平台下发【需要订阅的】
2.1.1  /server/dispatchFilterItem/DC2C26000976【黑白名单】
2.1.2
2.1.3
2.1.4
2.1.5
2.1.6
2.1.7
2.1.8  /server/dispatchOTP/DC2C26000976【一次性密码】【可以放弃！！！】
2.1.9
2.1.10 /server/deviceControlRequest/DC2C26000976【设备控制】【可以放弃！！！】
2.1.11
2.1.12 /server/uploadDeviceInfoRequest/DC2C26000976【请上传信息】
2.1.13
2.1.14
2.2设备上传【需要发布的】
2.2.1  /client/uploadAccessLog/DC2C26000976【通行日志】【平台如何回答？？？？？】
2.2.2  /client/uploadAccessSensor/DC2C26000976【门磁】
2.2.3  /client/uploadDeviceInfo/DC2C26000976【设备信息】
2.2.4  /client/uploadDeviceEvent/DC2C26000976【放弃】
2.2.5  /client/uploadDeviceMaintain/DC2C26000976【放弃】
2.2.6  
2.2.7  /client/filterRequest/DC2C26000976【黑白名单请求】
2.2.8  /client/response/DC2C26000976【统一回答】
2.2.9  
2.2.10  /client/keepAlive/DC2C26000976【心跳】
2.2.11  
2.2.12 

代码：
char topicPath[GMAX_MESSAGE_HANDLERS][45]={\
  "/server/timeCalibration/",\      【OK 平台发 我不回答】
  "/server/dispatchFilterItem/",\【OK 平台发 我回答】
  "/server/dispatchOTP/",\           【OK 平台发 我回答】
  "/server/deviceControlRequest/",\ 【OK 平台发 我回答】
  "/server/uploadDeviceInfoRequest/",\
    
  "/client/uploadAccessLog/",\【OK 我在触发的时候上报】
  "/client/uploadAccessSensor/",\  【OK 我在触发的时候上报】
  "/client/uploadDeviceInfo/",\ 【OK 我上报一次 以后回答它的问题在报】
  "/client/uploadDeviceEvent/",\
  "/client/uploadDeviceMaintain/",\
  "/client/filterRequest/",\
  "/client/response/",\   【OK 平台发 我回答】
  "/client/keepAlive/",\  【OK 我周期上报】
};
也即是
0--MQTIME
1--MQBW
2--MQOPW
3--MQCDR
4--MQIOR

5--MQLOG
6--MQSS
7--MQDI
8--MQDE
9--MQDM
10--MQBWR
11--MQRES
12--MQKL


收到：

处理时间OK：
 {"seqNo":"","data":{"timeStamp":1564722332040}} 
 
// {"seqNo":"","data":{"timeStamp":1564722332040}} 
char downtimeCalibration(char *pJson) 
{    
  SHOWME
    
  uint32_t stamp = 0;

  if(NULL == pJson) return 1;

  cJSON * pRoot = cJSON_Parse(pJson);

  if(NULL == pRoot) { cJSON_Delete(pRoot);  SHOWME  return 2;  }

  cJSON * pSub = cJSON_GetObjectItem(pRoot, "data");

  if(NULL == pSub)  {  cJSON_Delete(pRoot);  SHOWME return 2; }

  cJSON * pSub_2 = cJSON_GetObjectItem(pSub, "timeStamp");

  if(NULL == pSub_2) {  cJSON_Delete(pRoot); SHOWME return 2; }

 // printf("timeStamp : [%s]\n", pSub_2->valuestring); 无法输出 约定是long

  log(INFO,"获得服务器同步时间= %lf\n" ,  pSub_2->valuedouble);//1564725927916.000038 其实/1000 是1564725927

   
 // log(INFO,"获得服务器同步时间= %d\n" ,  pSub_2->valueint);//也不对！！long 不能用int 需要double
  
  stamp = pSub_2->valuedouble/1000;   //https://tool.lu/timestamp/ 输入毫秒准话为北京时间
		
  
  if( !Gequal( stamp, rtc.read_stamp(), 5))
  {
        log(DEBUG,"[需要修改时间]服务器返回时间戳 = %d , 设备当前时间戳 = %d\n" , stamp , rtc.read_stamp());
        rtc.set_time_form_stamp(stamp);
  } 
  return 0;
        
}




周期上报：心跳

mqttKEEPAliveBLUE =  timer.creat(10000 , FALSE , BLUE_keep_alive );
非常棒的逻辑是！！
10000是-000 也就是10S
看到是每次间隔10S我就给平台发数据一次！！！！
下面就是我发送的！！！
{
	"deviceNo":	"DC2C26000976",
	"timeStamp":	1564728962,
	"status":	1
}

####因为它 付出了很多内存 以后可以del一些 msg写小
完成设备信息上报：
最后的几个全部丢弃 不然会死机！！
不知道WHY 修改bug也不行！！！直接崩溃了
typedef struct
{
    uint32_t time;
    uint16_t id;
    uint8_t qos;
    uint16_t len;
    uint8_t  msg[400];---以前256比较小！！！
}mqttSendMsgType;
发现还是不行 还是小 需要 printf("MQTTPACKET_BUFFER_TOO_SHORT rem_len = %d\r\n",rem_len);这里看402
现在搞412吧！！
 ""---361
 NULL--342 它会消失掉！！！没有拉
char *cj_create_uploadDeviceInfo(int type,char *apkVersion) 
{
    cJSON *root = NULL;
    char *outStr;

    root =  cJSON_CreateObject();
    cJSON_AddStringToObject(root,"deviceNo", getDeviceId());
    cJSON_AddNumberToObject(root,"type", type);
    cJSON_AddStringToObject(root,"firmwareVersion", apkVersion);
    cJSON_AddStringToObject(root,"hardwareVersion", "V0.0.0");
    cJSON_AddStringToObject(root,"apkVersion", apkVersion);
    cJSON_AddStringToObject(root,"iccid", "");

    cJSON_AddStringToObject(root,"bluetoothMac", getBleMac());
    cJSON_AddStringToObject(root,"ipAddress", getselfIP());
    cJSON_AddStringToObject(root,"password",  getprojpwd());

    cJSON_AddStringToObject(root,"primarySipUrl", "");//空空如也
    cJSON_AddStringToObject(root,"primarySipAccount", "");
    cJSON_AddStringToObject(root,"primarySipPW", "");
    cJSON_AddStringToObject(root,"spareSipUrl", "");
    cJSON_AddStringToObject(root,"spareSipAccount", "");
    cJSON_AddStringToObject(root,"spareSipPW", NULL);====没有拉
 
    outStr = cJSON_Print(root);
    cJSON_Delete(root);

    printf("\r\n\r\n【%s】【%d】\r\n\r\n", outStr,strlen(outStr));
    return outStr;
}



下发开门：
{
	"type":	"1",
	"peopleId":	"GKOSON"
}

可以执行 我在返回执行结果
/client/response/DC2C26000976
可以看到我反馈结果


门磁上报：
触发的时候上报 结束的时候也上报
{
	"deviceNo":	"DC2C26000976",
	"logTime":	1564737246,
	"sensorStatus":	1
}

完成门内开门上报
face是空的


Gsubscribe /server/timeCalibration/ rc=0
Gsubscribe /server/dispatchFilterItem/DC2C26000976 rc=0
Gsubscribe /server/dispatchOTP/DC2C26000976 rc=0
Gsubscribe /server/deviceControlRequest/DC2C26000976 rc=0
Gsubscribe /server/uploadDeviceInfoRequest/DC2C26000976 rc=0

测试一次性密码 再次遇到那个问题！！！！！
{
	"password":"6543",
	"startTime":	1564737870,
	"expireDate":	5564737870,
	"isOTP":"1",
	"peopleId":"GKOSON"
}


typedef struct _cj_dispatchOTP
{
	char password[7] ;
	int  startTime;
	int  expireDate;
	char isOTP[2];-----------这里如果是1 就err!!!可以试试看
	char peopleId[10];
} cj_dispatchOTP;

错误全集：
1:主题必须是/server/dispatchOTP/DC2C26000976 最后面复制的时候多一个空格 则收不到！只是PC自己玩儿！

1写入正确
{
	"password":"6543",
	"startTime":	1564737870,
	"expireDate":	5564737870,
	"isOTP":"1",
	"peopleId":"GKOSON"
}
p->password 6543
p->startTime 1564737870
p->expireDate 2147483647
p->isOTP 1
p->peopleId GKOSON
pwd=25923---timea=1564737870----timeb=2147483647


2写错字母 expireTime
{
	"password":"6543",
	"startTime":	1564737870,
	"expireTime":	5564737870,
	"isOTP":"1",
	"peopleId":"GKOSON"
}
p->password 6543
p->startTime 1564737870
p->expireDate 0
p->isOTP 1
p->peopleId GKOSON
[#][0%][19-08-05 10:08:53]接到服务器下发一次性密码 JS错误

可以！！

2数据没有
{
	"password":"6543",
	"startTime":	1564737870,
	"isOTP":"1",
	"peopleId":"GKOSON"
}
p->password 6543
p->startTime 1564737870
p->expireDate 0
p->isOTP 1
p->peopleId GKOSON
[#][0%][19-08-05 10:10:01]接到服务器下发一次性密码 JS错误


3数据太多

	char cardNo[8] ;
	long timeStamp;
	char seqNo[8];
	long endTime;
	char filterType[2];




检测到身份证,UID :  [40 D1 BB 01 33 CE 64 98 ]
/server/dispatchFilterItem/DC2C26000976
下发黑白名单
{
	"cardNo":"40D1BB0133CE6498",
	"timeStamp":	1564737870,
	"seqNo":"35564737870556473787055647378702",
	"endTime":	5564737870,
	"filterType":"2"
}



/server/uploadDeviceInfoRequest/DC2C26000976
下发：
{
	"deviceNo":"DC2C26000976",
	"apkVersion":	100,
	"bluetoothMac":"DC2C26000976",
	"ipAddress":"2"
}
回答：
/client/uploadDeviceInfo/DC2C26000976





身份证流程：
[#][0%][19-08-05 15:48:04]#####upuploadAccessLog_card#####624######
JS is in /client/uploadAccessLog/DC2C26000976  [5]


【{
	"deviceNo":	"DC2C26000976",
	"openType":	0,
	"openTime":	1564991284,
	"lockStatus":	1,
	"openResult":	2,
	"parameters":	{
		"cardNo":	"40D1BB0133CE6498",
		"cardType":	4,
		"cardIssueType":	1
	}
}
无法开门

在发白名单
/server/dispatchFilterItem/DC2C26000976
{
	"cardNo":"40D1BB0133CE6498",
	"timeStamp":	1564737870,
	"seqNo":"35564737870556473787055647378702",
	"endTime":	5564737870,
	"filterType":"2"
}
可以开门了！！！




开门LOG
char *cj_create_uploadAccessLog_card(long openTime,char lockStatus,char openResult,    char *cardNo,int cardType,int cardIssueType) 
{
	cJSON *root = NULL;//基础类型
	cJSON *detail = NULL;//嵌套再里面的
	char *outStr;

	root =  cJSON_CreateObject();
	cJSON_AddStringToObject(root,"deviceNo", getDeviceId());
	cJSON_AddNumberToObject(root,"openType", 0);
	cJSON_AddNumberToObject(root,"openTime", openTime);
	cJSON_AddNumberToObject(root,"lockStatus", lockStatus);
	cJSON_AddNumberToObject(root,"openResult", openResult);


	detail =  cJSON_CreateObject();
	cJSON_AddStringToObject(detail,"cardNo", cardNo);
	cJSON_AddNumberToObject(detail,"cardType", cardType);
	cJSON_AddNumberToObject(detail,"cardIssueType", cardIssueType);

	cJSON_AddItemToObject(root, "parameters", detail);

	outStr = cJSON_Print(root);
	cJSON_Delete(root);
        
        RT_DEBUG_LOG(RT_DEBUG_IPC,("\r\n\r\n%s\r\n\r\n", outStr));
	return outStr;
}
嵌套的


{
	"deviceNo":	"3481F42EE3B2",
	"openType":	0,
	"openTime":	1565256752,
	"lockStatus":	0,
	"openResult":	0,
	"parameters":	{
		"cardNo":	"61928C1A952102E0",
		"cardType":	3,
		"cardIssueType":	2
	}
}


现在简单：
char *cj_create_uploadAccessLog_card(long openTime,char lockStatus,char openResult,    char *cardNo,int cardType,int cardIssueType) 
{
	cJSON *root = NULL;//基础类型

	char *outStr;

	root =  cJSON_CreateObject();
	cJSON_AddStringToObject(root,"deviceNo", getDeviceId());
	cJSON_AddNumberToObject(root,"openType", 0);
	cJSON_AddNumberToObject(root,"openTime", openTime);
	cJSON_AddNumberToObject(root,"lockStatus", lockStatus);
	cJSON_AddNumberToObject(root,"openResult", openResult);


	cJSON_AddStringToObject(root,"cardNo", cardNo);
	cJSON_AddNumberToObject(root,"cardType", cardType);
	cJSON_AddNumberToObject(root,"cardIssueType", cardIssueType);


	outStr = cJSON_Print(root);
	cJSON_Delete(root);
        
        RT_DEBUG_LOG(RT_DEBUG_IPC,("\r\n\r\n%s\r\n\r\n", outStr));
	return outStr;
}

{
	"deviceNo":	"3481F42EE3B2",
	"openType":	0,
	"openTime":	1565256752,
	"lockStatus":	0,
	"openResult":	0,
	"cardNo":	"61928C1A952102E0",
	"cardType":	3,
	"cardIssueType":	2
}


单向的 直接上报 没有回答！！



{"seqNo":"ff079030b9ac11e9bc0fa15554537da5","data":{"cardNo":"61928C1A952102E0","endTime":4102415999000,"filterType":1,"timeStamp":1565249703000}} 


{
"seqNo":"ff079030b9ac11e9bc0fa15554537da5",
"data":
{"cardNo":"61928C1A952102E0",
"endTime":4102415999000,
"filterType":1,-----------------这李变化了
"timeStamp":1565249703000
}
}

我做了一个CommonseqNo统一NO回答 现在只有黑白名单实现了其他带测试


int GparseJson(const char * pJson)
{
//入口判断
    if(NULL == pJson)
    {
        return 1;
    }
	
//直接解析	
    cJSON * pRoot = cJSON_Parse(pJson);
    if(NULL == pRoot)
    {
        return 2;
    }
	
//拿到	
    cJSON * pSub_1 = cJSON_GetObjectItem(pRoot, "seqNo");
    if(NULL == pSub_1)
    {
        cJSON_Delete(pRoot);
        return 3;
    }
	
    printf("get seqNo : [%s]\n", pSub_1->valuestring);
	
//拿到		
    pSub_1 = cJSON_GetObjectItem(pRoot, "data");
    if(NULL == pSub_1)
    {
        cJSON_Delete(pRoot);
        return 4;
    }
    printf("get data : [%s]\n", pSub_1->valuestring);
	
	
//拿到
    cJSON * pSub_2 = cJSON_GetObjectItem(pSub_1, "cardNo");
    if(NULL == pSub_2)
    {
        cJSON_Delete(pRoot);
        return 6;
    }
    printf("get cardNo : [%s]\n", pSub_2->valuestring);
	
//拿到
    pSub_2 = cJSON_GetObjectItem(pSub_1, "endTime");
    if(NULL == pSub_2)
    {
        cJSON_Delete(pRoot);
        return 7;
    }
    printf("get endTime\n");
	


    cJSON_Delete(pRoot);
    return 0;
} 

