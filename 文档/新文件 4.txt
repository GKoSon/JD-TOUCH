卡片数据测试

加密以后98个
0x92,0x33,0x84,0xE0,0x5E,0xBB,0x2E,0xC8,0xCD,0xC9,
0xA1,0x71,0x97,0x04,0x21,0xF5,0x10,0x28,0x97,0xB3,
0x6E,0xE9,0xE9,0x6D,0x89,0x7F,0x53,0xC6,0x6A,0x21,
0x38,0x68,0x94,0xEA,0xD4,0x62,0x99,0x3B,0x17,0x97,
0x98,0xF3,0xE3,0x73,0xB2,0x2A,0x92,0x5C,0x5A,0x6B,
0xB1,0x83,0x60,0xCC,0xB2,0xE7,0xCF,0x5E,0xD1,0x74,
0xB6,0xCE,0xD2,0x63,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x97

UID：0x57,0x74,0x8A,0xA8,0x06,0x23,0x02,0xE0

加密之前98个
0x01,0x02,0x51,0x57,0x88,0x48,0x37,0x13,0x25,0x19,
0x83,0x08,0x12,0x73,0x10,0x27,0x31,0x01,0x04,0x00,
0x40,0x05,0x00,0x10,0x00,0x00,0x01,0x99,0x12,0x31,
0xDA,0x02,0x31,0x01,0x04,0x00,0x40,0x05,0x00,0x10,
0x00,0x00,0x02,0x99,0x12,0x31,0xDB,0x02,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x97
===========================================

开始测试：
uint8_t A[98]={
0x92,0x33,0x84,0xE0,0x5E,0xBB,0x2E,0xC8,0xCD,0xC9,
0xA1,0x71,0x97,0x04,0x21,0xF5,0x10,0x28,0x97,0xB3,
0x6E,0xE9,0xE9,0x6D,0x89,0x7F,0x53,0xC6,0x6A,0x21,
0x38,0x68,0x94,0xEA,0xD4,0x62,0x99,0x3B,0x17,0x97,
0x98,0xF3,0xE3,0x73,0xB2,0x2A,0x92,0x5C,0x5A,0x6B,
0xB1,0x83,0x60,0xCC,0xB2,0xE7,0xCF,0x5E,0xD1,0x74,
0xB6,0xCE,0xD2,0x63,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x97};

uint8_t B[8]={0x57,0x74,0x8A,0xA8,0x06,0x23,0x02,0xE0};

if( tagComp->iso15693_read_data(0 , 98 ,tag_buffer) == FALSE)
{   
memcpy(tag_buffer,A,98);
memcpy(tag->UID,B,8);


void Decryptionr(unsigned char* SourceData,unsigned char *Key,unsigned char* PurposeData)
{
  for(i=0;i<8;i++) key[i]=Key[7-i];
 

 
  此时可以OK
  
  如下
[0;39m[0;37m[#][0%][17-11-24 07:24:09][CARD]tag->UID :  [F1 D4 71 37 04 23 02 E0 ]--真实卡

[0;39m[0;37m[#][0%][17-11-24 07:24:09]tag_buffer :  [92 33 84 E0 5E BB 2E C8 CD C9 A1 71 97 04 21 F5 10 28 97 B3 6E E9 E9 6D 89 7F 53 C6 6A 21 38 68 94 EA D4 62 99 3B 17 97 98 F3 E3 73 B2 2A 92 5C 5A 6B B1 83 60 CC B2 E7 CF 5E D1 74 B6 CE D2 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40 97 ]

[0;39m[0;37m[#][0%][17-11-24 07:24:09][CARD]key,UID :  [E0 02 23 06 A8 8A 74 57 ]--假的我的B翻转的

[0;39m[0;37m[#][0%][17-11-24 07:24:09]tag->buffer :  [01 02 51 57 88 48 37 13 25 19 83 08 12 73 10 27 31 01 04 00 40 05 00 10 00 00 01 99 12 31 DA 02 31 01 04 00 40 05 00 10 00 00 02 99 12 31 DB 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 40 97 ]


继续测试
//memcpy(tag_buffer,A,98);
//memcpy(tag->UID,B,8);
放弃上面 使用真实卡的话
[0;39m[0;37m[#][0%][17-11-24 07:26:43][CARD]tag->UID :  [F1 D4 71 37 04 23 02 E0 ]--真实卡

[0;39m[0;37m[#][0%][17-11-24 07:26:43]tag_buffer :  [FB 5F 4B AF 6B 03 20 07 AE 0B B4 BC 29 1B 54 62 DF C7 E9 2E 37 78 38 93 CE 1D 57 9F 9D 61 53 BB D2 97 87 38 7B 69 C3 13 2E 39 53 EE F7 C1 C9 EC 65 60 62 F6 46 D2 62 0D 1B B2 2A 50 F1 C7 CF B4 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0C B8 ]

[0;39m[0;37m[#][0%][17-11-24 07:26:43][CARD]key,UID :  [E0 02 23 04 37 71 D4 F1 ]--真实翻转

[0;39m[0;37m[#][0%][17-11-24 07:26:43]tag->buffer :  [58 82 EF 43 37 96 B8 D1 D7 86 57 A9 F2 23 30 4E CF D2 62 F8 39 79 81 DB 89 7E 16 DF 6E 5E D1 A4 3F 43 BB 4E B6 CB C1 7A A6 51 14 F7 3C CB 64 A8 D5 FE F4 65 D8 ED 0D 7D 76 4C E7 49 2D F6 66 11 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0C B8 ]

结论：微信给的三组数据可以自圆其说 但是真实给的卡不行 解密出来不对
质疑1--卡没有发好 2--卡写的块儿不对